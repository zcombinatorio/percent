/*
 * Copyright (C) 2025 Spice Finance Inc.
 *
 * This file is part of Z Combinator.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

import { Transaction } from '@solana/web3.js';
import toast from 'react-hot-toast';
import { buildApiUrl, withModeratorId } from './api-utils';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';

// SOL mint address (quote token)
const SOL_MINT = 'So11111111111111111111111111111111111111112';
const SOL_DECIMALS = 9;

export interface OpenPositionConfig {
  proposalId: number;
  market: 'pass' | 'fail';  // Which AMM market to trade on
  inputToken: 'sol' | 'baseToken';  // Which conditional token we're selling
  inputAmount: string;  // Amount of conditional tokens to sell
  userAddress: string;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
  baseDecimals?: number;  // Decimals for the base token (default 6)
  moderatorId?: number;  // Moderator ID for multi-moderator support
}

export interface ClosePositionConfig {
  proposalId: number;
  positionType: 'pass' | 'fail';
  percentageToClose: number; // 1-100
  userAddress: string;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
  moderatorId?: number;  // Moderator ID for multi-moderator support
}

/**
 * Execute a swap on a specific market (Pass or Fail AMM)
 * Swaps conditional tokens: e.g., Pass-ZC → Pass-SOL or Fail-SOL → Fail-ZC
 */
export async function openPosition(config: OpenPositionConfig): Promise<void> {
  const { proposalId, market, inputToken, inputAmount, userAddress, signTransaction, baseDecimals = 6, moderatorId } = config;

  // Determine swap direction based on inputToken
  // inputToken 'baseToken' means we're selling base conditional for quote (SOL conditional)
  // inputToken 'sol' means we're selling quote (SOL conditional) for base conditional
  const isBaseToQuote = inputToken === 'baseToken';

  const toastId = toast.loading(`Swapping ${market}-${inputToken.toUpperCase()}...`);

  try {
    // Convert decimal amount to smallest units using dynamic decimals
    const decimals = inputToken === 'baseToken' ? baseDecimals : SOL_DECIMALS;
    const amountInSmallestUnits = Math.floor(parseFloat(inputAmount) * Math.pow(10, decimals)).toString();

    // Execute the swap on the selected market
    await executeMarketSwap(
      proposalId,
      market,
      isBaseToQuote,
      amountInSmallestUnits,
      userAddress,
      signTransaction,
      moderatorId
    );

    // Success message
    const outputToken = inputToken === 'baseToken' ? 'SOL' : 'BASE';
    toast.success(
      `Successfully swapped ${market}-${inputToken.toUpperCase()} → ${market}-${outputToken}!`,
      { id: toastId, duration: 5000 }
    );

  } catch (error) {
    console.error('Error executing swap:', error);
    toast.error(
      `Failed to execute swap: ${error instanceof Error ? error.message : 'Unknown error'}`,
      { id: toastId }
    );
    throw error;
  }
}

/**
 * Close a position (pass or fail) by a certain percentage
 */
export async function closePosition(config: ClosePositionConfig): Promise<void> {
  const { proposalId, positionType, percentageToClose, userAddress, signTransaction, moderatorId } = config;

  if (percentageToClose <= 0 || percentageToClose > 100) {
    throw new Error('Percentage to close must be between 1 and 100');
  }

  const toastId = toast.loading(`Closing ${percentageToClose}% of position...`);

  try {
    // Step 1: Get current balances to determine amounts to close
    const currentBalances = await getUserBalances(proposalId, userAddress, moderatorId);
    if (!currentBalances) {
      throw new Error('Failed to get current balances');
    }

    // Step 2: Calculate amounts to close based on position type and percentage
    const amountsToClose = calculateCloseAmounts(currentBalances, positionType, percentageToClose);

    // Step 3: Execute reverse swaps to prepare for merging
    await executeReverseSwaps(
      proposalId,
      positionType,
      amountsToClose,
      userAddress,
      signTransaction,
      moderatorId
    );

    // Step 4: Get updated balances after swaps
    const balancesAfterSwaps = await getUserBalances(proposalId, userAddress, moderatorId);
    if (!balancesAfterSwaps) {
      throw new Error('Failed to get balances after swaps');
    }

    // Step 5: Merge conditional tokens back to regular tokens
    await mergeConditionalTokens(
      proposalId,
      balancesAfterSwaps,
      userAddress,
      signTransaction,
      moderatorId
    );
    
    toast.success(
      `Successfully closed ${percentageToClose}% of position!`,
      { id: toastId, duration: 5000 }
    );
    
  } catch (error) {
    console.error('Error closing position:', error);
    toast.error(
      `Failed to close position: ${error instanceof Error ? error.message : 'Unknown error'}`,
      { id: toastId }
    );
    throw error;
  }
}

/**
 * Calculate amounts to close based on current balances, position type, and percentage
 */
function calculateCloseAmounts(balances: any, positionType: 'pass' | 'fail', percentage: number): any {
  const factor = percentage / 100;
  
  if (positionType === 'pass') {
    // Pass position has pBase + fQuote, we want to swap back
    const fQuoteAmount = parseFloat(balances.quote.failConditional || '0');
    
    return {
      pBaseToSwap: "0",
      fQuoteToSwap: Math.floor(fQuoteAmount * factor).toString()
    };
  } else {
    // Fail position has fBase + pQuote, we want to swap back
    const pQuoteAmount = parseFloat(balances.quote.passConditional || '0');
    
    return {
      fBaseToSwap: "0",
      pQuoteToSwap: Math.floor(pQuoteAmount * factor).toString()
    };
  }
}

/**
 * Execute reverse swaps to prepare conditional tokens for merging
 */
async function executeReverseSwaps(
  proposalId: number,
  positionType: 'pass' | 'fail',
  amountsToClose: any,
  userAddress: string,
  signTransaction: (transaction: Transaction) => Promise<Transaction>,
  moderatorId?: number
): Promise<void> {

  if (positionType === 'pass') {
    // Reverse pass position: pBase + fQuote → pQuote + fBase

    // Swap pBase → pQuote on pass market
    if (amountsToClose.pBaseToSwap && amountsToClose.pBaseToSwap !== '0') {
      await executeMarketSwap(
        proposalId,
        'pass',
        true, // base to quote
        amountsToClose.pBaseToSwap,
        userAddress,
        signTransaction,
        moderatorId
      );
    }

    // Swap fQuote → fBase on fail market
    if (amountsToClose.fQuoteToSwap && amountsToClose.fQuoteToSwap !== '0') {
      await executeMarketSwap(
        proposalId,
        'fail',
        false, // quote to base
        amountsToClose.fQuoteToSwap,
        userAddress,
        signTransaction,
        moderatorId
      );
    }

  } else {
    // Reverse fail position: fBase + pQuote → fQuote + pBase

    // Swap fBase → fQuote on fail market
    if (amountsToClose.fBaseToSwap && amountsToClose.fBaseToSwap !== '0') {
      await executeMarketSwap(
        proposalId,
        'fail',
        true, // base to quote
        amountsToClose.fBaseToSwap,
        userAddress,
        signTransaction,
        moderatorId
      );
    }

    // Swap pQuote → pBase on pass market
    if (amountsToClose.pQuoteToSwap && amountsToClose.pQuoteToSwap !== '0') {
      await executeMarketSwap(
        proposalId,
        'pass',
        false, // quote to base
        amountsToClose.pQuoteToSwap,
        userAddress,
        signTransaction,
        moderatorId
      );
    }
  }
}

/**
 * Merge conditional tokens back to regular tokens where possible
 */
async function mergeConditionalTokens(
  proposalId: number,
  balances: any,
  userAddress: string,
  signTransaction: (transaction: Transaction) => Promise<Transaction>,
  moderatorId?: number
): Promise<void> {

  const pBase = parseFloat(balances.base.passConditional || '0');
  const fBase = parseFloat(balances.base.failConditional || '0');
  const pQuote = parseFloat(balances.quote.passConditional || '0');
  const fQuote = parseFloat(balances.quote.failConditional || '0');

  // Merge base tokens if user has both pBase and fBase
  const baseMergeAmount = Math.min(pBase, fBase);
  console.log("base merge amount:", baseMergeAmount);
  if (baseMergeAmount > 0) {
    await mergeTokens(
      proposalId,
      'base',
      Math.floor(baseMergeAmount).toString(),
      userAddress,
      signTransaction,
      moderatorId
    );
  }

  // Merge quote tokens if user has both pQuote and fQuote
  const quoteMergeAmount = Math.min(pQuote, fQuote);
  if (quoteMergeAmount > 0) {
    await mergeTokens(
      proposalId,
      'quote',
      Math.floor(quoteMergeAmount).toString(),
      userAddress,
      signTransaction,
      moderatorId
    );
  }
}

/**
 * Merge tokens via vault (base or quote)
 */
async function mergeTokens(
  proposalId: number,
  vaultType: 'base' | 'quote',
  amount: string,
  userAddress: string,
  signTransaction: (transaction: Transaction) => Promise<Transaction>,
  moderatorId?: number
): Promise<void> {

  // Build merge transaction
  const mergeRequest = {
    user: userAddress,
    amount: amount
  };

  const mergeResponse = await fetch(buildApiUrl(API_BASE_URL, `/api/vaults/${proposalId}/${vaultType}/buildMergeTx`, undefined, moderatorId), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(mergeRequest)
  });

  if (!mergeResponse.ok) {
    const error = await mergeResponse.json();
    throw new Error(`${vaultType} merge failed: ${error.message || JSON.stringify(error)}`);
  }

  const mergeData = await mergeResponse.json();

  // Sign the transaction
  const mergeTx = Transaction.from(Buffer.from(mergeData.transaction, 'base64'));
  const signedMergeTx = await signTransaction(mergeTx);

  // Execute the signed merge transaction
  const executeMergeResponse = await fetch(buildApiUrl(API_BASE_URL, `/api/vaults/${proposalId}/${vaultType}/executeMergeTx`, undefined, moderatorId), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      transaction: Buffer.from(signedMergeTx.serialize({ requireAllSignatures: false })).toString('base64')
    })
  });

  if (!executeMergeResponse.ok) {
    const error = await executeMergeResponse.json();
    throw new Error(`${vaultType} merge execution failed: ${error.message || JSON.stringify(error)}`);
  }
}

/**
 * Get user balances for a proposal
 */
async function getUserBalances(proposalId: number, userAddress: string, moderatorId?: number): Promise<any> {
  const balancesResponse = await fetch(
    buildApiUrl(API_BASE_URL, `/api/vaults/${proposalId}/getUserBalances`, { user: userAddress }, moderatorId)
  );

  if (balancesResponse.ok) {
    return await balancesResponse.json();
  }

  return null;
}

/**
 * Split tokens via vault (base or quote)
 */
async function splitTokens(
  proposalId: number,
  vaultType: 'base' | 'quote',
  amount: string,
  userAddress: string,
  signTransaction: (transaction: Transaction) => Promise<Transaction>,
  moderatorId?: number
): Promise<void> {

  // Build split transaction
  const splitRequest = {
    user: userAddress,
    amount: amount
  };

  const splitResponse = await fetch(buildApiUrl(API_BASE_URL, `/api/vaults/${proposalId}/${vaultType}/buildSplitTx`, undefined, moderatorId), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(splitRequest)
  });

  if (!splitResponse.ok) {
    const error = await splitResponse.json();
    throw new Error(`${vaultType} split failed: ${error.message || JSON.stringify(error)}`);
  }

  const splitData = await splitResponse.json();

  // Sign the transaction using the wallet
  const splitTx = Transaction.from(Buffer.from(splitData.transaction, 'base64'));
  const signedTx = await signTransaction(splitTx);

  // Execute the signed split transaction
  const executeSplitResponse = await fetch(buildApiUrl(API_BASE_URL, `/api/vaults/${proposalId}/${vaultType}/executeSplitTx`, undefined, moderatorId), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      transaction: Buffer.from(signedTx.serialize({ requireAllSignatures: false })).toString('base64')
    })
  });

  if (!executeSplitResponse.ok) {
    const error = await executeSplitResponse.json();
    throw new Error(`${vaultType} split execution failed: ${error.message || JSON.stringify(error)}`);
  }
}

/**
 * Claim winnings from a finished proposal
 * Claims from BOTH vaults (base and quote) for the winning market
 */
export async function claimWinnings(config: {
  proposalId: number;
  proposalStatus: 'Passed' | 'Failed';
  userPosition: { type: 'pass' | 'fail' } | null;
  userAddress: string;
  signTransaction: (transaction: Transaction) => Promise<Transaction>;
  moderatorId?: number;
}): Promise<void> {
  const { proposalId, proposalStatus, userAddress, signTransaction, moderatorId } = config;

  // Check if user won
  const didUserWin = (proposalStatus === 'Passed' && config.userPosition?.type === 'pass') ||
                     (proposalStatus === 'Failed' && config.userPosition?.type === 'fail');

  if (!didUserWin) {
    throw new Error('Cannot claim - you did not win this market');
  }

  const toastId = toast.loading('Claiming winnings from both vaults...');

  try {
    // Get user balances to determine which vaults have claimable tokens
    const balances = await getUserBalances(proposalId, userAddress, moderatorId);
    if (!balances) {
      throw new Error('Failed to get user balances');
    }

    // Determine which conditional tokens the user has based on outcome
    let hasBaseTokens = false;
    let hasQuoteTokens = false;

    if (proposalStatus === 'Passed') {
      // Proposal passed - user can claim Pass conditional tokens
      hasBaseTokens = parseFloat(balances.base.passConditional || '0') > 0;
      hasQuoteTokens = parseFloat(balances.quote.passConditional || '0') > 0;
    } else {
      // Proposal failed - user can claim Fail conditional tokens
      hasBaseTokens = parseFloat(balances.base.failConditional || '0') > 0;
      hasQuoteTokens = parseFloat(balances.quote.failConditional || '0') > 0;
    }

    const vaultsToRedeem: ('base' | 'quote')[] = [];
    if (hasBaseTokens) vaultsToRedeem.push('base');
    if (hasQuoteTokens) vaultsToRedeem.push('quote');

    if (vaultsToRedeem.length === 0) {
      throw new Error('No winning tokens to claim');
    }

    // Redeem from each vault that has tokens
    for (const vaultType of vaultsToRedeem) {
      // Build redeem transaction
      const redeemResponse = await fetch(
        buildApiUrl(API_BASE_URL, `/api/vaults/${proposalId}/${vaultType}/buildRedeemWinningTokensTx`, undefined, moderatorId),
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            user: userAddress
          })
        }
      );

      if (!redeemResponse.ok) {
        const error = await redeemResponse.json();
        throw new Error(`Failed to build ${vaultType} redeem transaction: ${error.message || JSON.stringify(error)}`);
      }

      const redeemData = await redeemResponse.json();

      // Sign the transaction
      const redeemTx = Transaction.from(Buffer.from(redeemData.transaction, 'base64'));
      const signedRedeemTx = await signTransaction(redeemTx);

      // Execute the signed redeem transaction
      const executeRedeemResponse = await fetch(
        buildApiUrl(API_BASE_URL, `/api/vaults/${proposalId}/${vaultType}/executeRedeemWinningTokensTx`, undefined, moderatorId),
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            transaction: Buffer.from(signedRedeemTx.serialize({ requireAllSignatures: false })).toString('base64')
          })
        }
      );

      if (!executeRedeemResponse.ok) {
        const error = await executeRedeemResponse.json();
        throw new Error(`Failed to execute ${vaultType} redeem transaction: ${error.message || JSON.stringify(error)}`);
      }
    }

    toast.success(
      `Winnings claimed successfully from ${vaultsToRedeem.length} vault${vaultsToRedeem.length > 1 ? 's' : ''}!`,
      { id: toastId, duration: 5000 }
    );

    return;
    
  } catch (error) {
    console.error('Error claiming winnings:', error);
    toast.error(
      `Failed to claim winnings: ${error instanceof Error ? error.message : 'Unknown error'}`,
      { id: toastId }
    );
    throw error;
  }
}

/**
 * Execute a swap on pass or fail market
 */
async function executeMarketSwap(
  proposalId: number,
  market: 'pass' | 'fail',
  isBaseToQuote: boolean,
  amountIn: string,
  userAddress: string,
  signTransaction: (transaction: Transaction) => Promise<Transaction>,
  moderatorId?: number
): Promise<void> {

  // Build swap request
  const swapRequest = {
    user: userAddress,
    market: market,
    isBaseToQuote: isBaseToQuote,
    amountIn: amountIn,
    slippageBps: 2000 // 20% slippage for large swaps
  };

  const buildSwapResponse = await fetch(buildApiUrl(API_BASE_URL, `/api/swap/${proposalId}/buildSwapTx`, undefined, moderatorId), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(swapRequest)
  });

  if (!buildSwapResponse.ok) {
    const error = await buildSwapResponse.json();
    throw new Error(`Build ${market} swap failed: ${error.message || JSON.stringify(error)}`);
  }

  const swapTxData = await buildSwapResponse.json();

  // Sign the swap transaction
  const swapTx = Transaction.from(Buffer.from(swapTxData.transaction, 'base64'));
  const signedSwapTx = await signTransaction(swapTx);

  // Execute the signed swap transaction
  const executeSwapResponse = await fetch(buildApiUrl(API_BASE_URL, `/api/swap/${proposalId}/executeSwapTx`, undefined, moderatorId), {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      transaction: Buffer.from(signedSwapTx.serialize({ requireAllSignatures: false })).toString('base64'),
      market: market,
      user: userAddress,
      isBaseToQuote: isBaseToQuote,
      amountIn: amountIn,
      amountOut: swapTxData.expectedAmountOut
    })
  });
  
  if (!executeSwapResponse.ok) {
    const error = await executeSwapResponse.json();
    throw new Error(`${market} swap execution failed: ${error.message || JSON.stringify(error)}`);
  }
}